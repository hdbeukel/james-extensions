/*
 * Copyright 2014 Ghent University, Bayer CropScience.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jamesframework.ext.search.neigh;

import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ThreadLocalRandom;
import org.jamesframework.core.problems.solutions.Solution;
import org.jamesframework.core.search.neigh.Move;
import org.jamesframework.core.search.neigh.Neighbourhood;
import org.jamesframework.core.util.RouletteSelector;

/**
 * A composite neighbourhood combines a collection of other neighbourhoods which each have a weight that determines
 * the relative frequency with which random moves are sampled from each contained neighbourhood. When requesting
 * a random move to the composite neighbourhood, one contained neighbourhood is picked through roulette selection
 * with the weights given at construction. Then, a random move created by this neighbourhood is returned (if any).
 * When requesting all moves, the union of all moves generated by all contained neighbourhoods is returned.
 * 
 * @param <SolutionType> solution type for which this neighbourhood can be applied, required to extend {@link Solution}
 * @author <a href="mailto:herman.debeukelaer@ugent.be">Herman De Beukelaer</a>
 */
public class CompositeNeighbourhood<SolutionType extends Solution> implements Neighbourhood<SolutionType>{

    // contained neighbourhoods
    private final List<Neighbourhood<SolutionType>> neighs;
    // neighbourhood weights
    private final List<Double> weights;

    /**
     * Creates a composite neighbourhood consisting of the list of given neighbourhoods and specified weights. The
     * list of neighbourhoods and weights can not be <code>null</code>, should be of the same size and can not contain
     * any <code>null</code> elements. At least one neighbourhood should be given and all weights should be strictly
     * positive.
     * 
     * @param neighbourhoods list of neighbourhoods
     * @param neighbourhoodWeights weights assigned to each neighbourhood (same order as neighbourhoods)
     * @throws NullPointerException if <code>neighbourhoods</code> or <code>neighbourhoodWeights</code> are
     *                              <code>null</code> or contain any <code>null</code> elements
     * @throws IllegalArgumentException if <code>neighbourhoods</code> and <code>neighbourhoodWeights</code> are
     *                                  not of the same size or both empty, or if <code>neighbourhoodWeights</code>
     *                                  contains any weight &le; 0
     */
    public CompositeNeighbourhood(List<Neighbourhood<SolutionType>> neighbourhoods, List<Double> neighbourhoodWeights) {
        // check not null
        if(neighbourhoods == null){
            throw new NullPointerException("Neighbourhood list can not be null.");
        }
        if(neighbourhoodWeights == null){
            throw new NullPointerException("Neighbourhood weight list can not be null.");
        }
        // check size
        if(neighbourhoods.size() != neighbourhoodWeights.size()){
            throw new IllegalArgumentException("Neighbourhood and weight list should be of the same size.");
        }
        if(neighbourhoods.isEmpty()){
            throw new IllegalArgumentException("At least one neighbourhood should be specified.");
        }
        // inspect list contents
        for(Neighbourhood<SolutionType> n : neighbourhoods){
            if(n == null){
                throw new NullPointerException("Neighbourhood list can not contain any null elements.");
            }
        }
        for(Double w : neighbourhoodWeights){
            if(w == null){
                throw new NullPointerException("Neighbourhood weight list can not contain any null elements.");
            }
            if(w <= 0){
                throw new IllegalArgumentException("All weights should be strictly positive.");
            }
        }
        // store neighbourhoods and weights
        this.neighs = neighbourhoods;
        this.weights = neighbourhoodWeights;
    }
    
    /**
     * Randomly picks a contained neighbourhood through roulette selection with the respective weights and
     * returns a move obtained by calling {@link #getRandomMove(Solution)} on the selected neighbourhood.
     * May return <code>null</code> if the selected neighbourhood is unable to generate a random move.
     * 
     * @param solution solution for which a move is generated
     * @return random move generated by one of the contained neighbourhoods, which is selected by
     *         roulette selection based on the respective weights
     */
    @Override
    public Move<? super SolutionType> getRandomMove(SolutionType solution) {
        // roulette selection to pick a neighbourhood
        Random rg = ThreadLocalRandom.current();
        RouletteSelector<Neighbourhood<SolutionType>> roulette = new RouletteSelector<>(rg);
        Neighbourhood<SolutionType> neigh = roulette.select(neighs, weights);
        // generate and return random move with selected neighbourhood
        return neigh.getRandomMove(solution);
    }

    /**
     * Creates and returns the union of the sets of all moves generated by each of the contained neighbourhoods.
     * The returned set may be empty if none of the contained neighbourhoods can generate any move.
     * 
     * @param solution solution for which all moves are generated
     * @return union of all possible moves generated by each contained neighbourhood
     */
    @Override
    public Set<Move<? super SolutionType>> getAllMoves(SolutionType solution) {
        Set<Move<? super SolutionType>> moves = new HashSet<>();
        for(Neighbourhood<SolutionType> neigh : neighs){
            moves.addAll(neigh.getAllMoves(solution));
        }
        return moves;
    }

}
